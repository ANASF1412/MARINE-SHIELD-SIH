"""YOLOv8 model utilities for training and inference."""

from __future__ import annotations

import logging
from pathlib import Path
from typing import Any, Dict, List

import numpy as np
from PIL import Image
from ultralytics import YOLO

from config import (
    CONFIDENCE_THRESHOLD,
    DATASET_YAML,
    IOU_THRESHOLD,
    MODEL_DIR,
    YOLO_BASE_MODEL,
    YOLO_MODEL_PATH,
)

LOGGER = logging.getLogger(__name__)


class YOLOModelManager:
    """Encapsulates YOLOv8 load, train, and inference helpers."""

    def __init__(self, weights_path: Path | None = None) -> None:
        self.weights_path = weights_path or YOLO_MODEL_PATH
        self.model = self._load_model(self.weights_path)

    @staticmethod
    def _load_model(weights_path: Path) -> YOLO:
        if not weights_path.exists():
            raise FileNotFoundError(
                f"YOLO weights not found at {weights_path}. Train the model or download weights first."
            )

        LOGGER.info("Loading YOLO model from %s", weights_path)
        return YOLO(str(weights_path))

    def train(
        self,
        data_yaml: Path = DATASET_YAML,
        epochs: int = 100,
        imgsz: int = 640,
        batch: int = 16,
        lr0: float = 0.001,
        patience: int = 15,
        name: str = "oil_spill_training",
    ) -> Any:
        """Train YOLOv8 model and return training results."""
        data_yaml = Path(data_yaml)
        if not data_yaml.exists():
            raise FileNotFoundError(f"Training data YAML not found at {data_yaml}")

        LOGGER.info("Starting YOLO training using data: %s", data_yaml)
        model = YOLO(YOLO_BASE_MODEL)
        results = model.train(
            data=str(data_yaml),
            epochs=epochs,
            imgsz=imgsz,
            batch=batch,
            lr0=lr0,
            patience=patience,
            name=name,
            exist_ok=True,
        )
        return results

    def predict(self, image_path: Path) -> List[Dict[str, Any]]:
        LOGGER.debug("Running prediction on %s", image_path)
        results = self.model.predict(
            source=str(image_path),
            conf=CONFIDENCE_THRESHOLD,
            iou=IOU_THRESHOLD,
            verbose=False,
        )[0]

        predictions: List[Dict[str, Any]] = []
        for box in results.boxes:
            bbox = box.xyxy[0].cpu().numpy().tolist()
            predictions.append(
                {
                    "bbox": bbox,
                    "confidence": float(box.conf[0]),
                    "class_id": int(box.cls[0]),
                    "class_name": results.names[int(box.cls[0])],
                }
            )

        return predictions

    def render_predictions(self, image_path: Path, output_path: Path) -> Path:
        """Run inference and save the annotated image for visualization."""
        results = self.model.predict(
            source=str(image_path),
            conf=CONFIDENCE_THRESHOLD,
            iou=IOU_THRESHOLD,
            save=True,
            exist_ok=True,
            project=str(output_path.parent),
            name=output_path.stem,
        )

        # YOLO saves result as <project>/<name>/image.jpg - move/rename to expected path
        pred_dir = Path(results[0].save_dir)
        saved_images = list(pred_dir.glob("*.jpg")) + list(pred_dir.glob("*.png"))
        if not saved_images:
            raise FileNotFoundError("No annotated image generated by YOLO during render.")

        saved_image = saved_images[0]
        output_path.parent.mkdir(parents=True, exist_ok=True)
        saved_image.rename(output_path)
        LOGGER.info("Annotated image saved to %s", output_path)
        return output_path

    @staticmethod
    def load_image(image_path: Path) -> np.ndarray:
        """Load image as numpy array using PIL for PDF embedding."""
        with Image.open(image_path) as img:
            return np.array(img.convert("RGB"))